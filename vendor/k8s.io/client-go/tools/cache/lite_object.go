package cache

import (
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

type LiteObject struct {
	name            string
	namespace       string
	resourceVersion string
	uid             types.UID
	clusterName     string
}

func (obj *LiteObject) GetNamespace() string {
	return obj.namespace
}

func (obj *LiteObject) SetNamespace(namespace string) {
	obj.namespace = namespace
}

func (obj *LiteObject) GetName() string {
	return obj.name
}

func (obj *LiteObject) SetName(name string) {
	obj.name = name
}

func (obj *LiteObject) GetGenerateName() string {
	panic("implement me")
}

func (obj *LiteObject) SetGenerateName(name string) {
	panic("implement me")
}

func (obj *LiteObject) GetUID() types.UID {
	return obj.uid
}

func (obj *LiteObject) SetUID(uid types.UID) {
	obj.uid = uid
}

func (obj *LiteObject) GetResourceVersion() string {
	return obj.resourceVersion
}

func (obj *LiteObject) SetResourceVersion(resourceVersion string) {
	obj.resourceVersion = resourceVersion
}

func (obj *LiteObject) GetGeneration() int64 {
	panic("implement me")
}

func (obj *LiteObject) SetGeneration(generation int64) {
	panic("implement me")
}

func (obj *LiteObject) GetSelfLink() string {
	panic("implement me")
}

func (obj *LiteObject) SetSelfLink(_ string) {
	panic("implement me")
}

func (obj *LiteObject) GetCreationTimestamp() metav1.Time {
	panic("implement me")
}

func (obj *LiteObject) SetCreationTimestamp(_ metav1.Time) {
	panic("implement me")
}

func (obj *LiteObject) GetDeletionTimestamp() *metav1.Time {
	panic("implement me")
}

func (obj *LiteObject) SetDeletionTimestamp(_ *metav1.Time) {
	panic("implement me")
}

func (obj *LiteObject) GetDeletionGracePeriodSeconds() *int64 {
	panic("implement me")
}

func (obj *LiteObject) SetDeletionGracePeriodSeconds(_ *int64) {
	panic("implement me")
}

func (obj *LiteObject) GetLabels() map[string]string {
	panic("implement me")
}

func (obj *LiteObject) SetLabels(_ map[string]string) {
	panic("implement me")
}

func (obj *LiteObject) GetAnnotations() map[string]string {
	panic("implement me")
}

func (obj *LiteObject) SetAnnotations(_ map[string]string) {
	panic("implement me")
}

func (obj *LiteObject) GetFinalizers() []string {
	panic("implement me")
}

func (obj *LiteObject) SetFinalizers(_ []string) {
	panic("implement me")
}

func (obj *LiteObject) GetOwnerReferences() []metav1.OwnerReference {
	panic("implement me")
}

func (obj *LiteObject) SetOwnerReferences(_ []metav1.OwnerReference) {
	panic("implement me")
}

func (obj *LiteObject) GetClusterName() string {
	return obj.clusterName
}

func (obj *LiteObject) SetClusterName(clusterName string) {
	obj.clusterName = clusterName
}

func (obj *LiteObject) GetManagedFields() []metav1.ManagedFieldsEntry {
	panic("implement me")
}

func (obj *LiteObject) SetManagedFields(_ []metav1.ManagedFieldsEntry) {
	panic("implement me")
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (obj *LiteObject) DeepCopyInto(out *LiteObject) {
	*out = *obj
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LiteObject.
func (obj *LiteObject) DeepCopy() *LiteObject {
	if obj == nil {
		return nil
	}
	out := new(LiteObject)
	obj.DeepCopyInto(out)
	return out
}

func NewLiteObject(obj interface{}) (interface{}, error) {
	if _, ok := obj.(DeletedFinalStateUnknown); ok {
		return obj, nil
	}
	if _, ok := obj.(ExplicitKey); ok {
		return obj, nil
	}
	m, err := meta.Accessor(obj)
	if err != nil {
		return nil, err
	}
	return &LiteObject{
		name:            m.GetName(),
		namespace:       m.GetNamespace(),
		resourceVersion: m.GetResourceVersion(),
		uid:             m.GetUID(),
		clusterName:     m.GetClusterName(),
	}, nil
}

func MustLiteObject(obj interface{}) interface{} {
	out, err := NewLiteObject(obj)
	if err != nil {
		panic(err)
	}
	return out
}

// liteMap implements ThreadSafeStore
type liteMap struct {
	delegate ThreadSafeStore
}

func (c *liteMap) Add(key string, obj interface{}) {
	c.delegate.Add(key, MustLiteObject(obj))
}

func (c *liteMap) Update(key string, obj interface{}) {
	c.delegate.Update(key, MustLiteObject(obj))
}

func (c *liteMap) Delete(key string) {
	c.delegate.Delete(key)
}

func (c *liteMap) Get(key string) (item interface{}, exists bool) {
	return c.delegate.Get(key)
}

func (c *liteMap) List() []interface{} {
	return c.delegate.List()
}

// ListKeys returns a list of all the keys of the objects currently
// in the liteMap.
func (c *liteMap) ListKeys() []string {
	return c.delegate.ListKeys()
}

func (c *liteMap) Replace(items map[string]interface{}, resourceVersion string) {
	liteObjs := make(map[string]interface{}, len(items))
	for key, item := range items {
		liteObjs[key] = MustLiteObject(item)
	}
	c.delegate.Replace(liteObjs, resourceVersion)
}

// Index returns a list of items that match the given object on the index function.
// Index is thread-safe so long as you treat all items as immutable.
func (c *liteMap) Index(indexName string, obj interface{}) ([]interface{}, error) {
	return c.delegate.Index(indexName, MustLiteObject(obj))
}

// ByIndex returns a list of the items whose indexed values in the given index include the given indexed value
func (c *liteMap) ByIndex(indexName, indexedValue string) ([]interface{}, error) {
	return c.delegate.ByIndex(indexName, indexedValue)
}

// IndexKeys returns a list of the Store keys of the objects whose indexed values in the given index include the given indexed value.
// IndexKeys is thread-safe so long as you treat all items as immutable.
func (c *liteMap) IndexKeys(indexName, indexedValue string) ([]string, error) {
	return c.delegate.IndexKeys(indexName, indexedValue)
}

func (c *liteMap) ListIndexFuncValues(indexName string) []string {
	return c.delegate.ListIndexFuncValues(indexName)
}

func (c *liteMap) GetIndexers() Indexers {
	return c.delegate.GetIndexers()
}

func (c *liteMap) AddIndexers(newIndexers Indexers) error {
	return c.delegate.AddIndexers(newIndexers)
}

func (c *liteMap) Resync() error {
	// Nothing to do
	return nil
}

// NewLiteThreadSafeStore creates a new instance of ThreadSafeStore.
func NewLiteThreadSafeStore(indexers Indexers, indices Indices) ThreadSafeStore {
	return &liteMap{
		delegate: NewThreadSafeStore(indexers, indices),
	}
}
